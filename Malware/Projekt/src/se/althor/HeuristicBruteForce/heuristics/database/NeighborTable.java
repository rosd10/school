/**
 * 
 */
package se.althor.HeuristicBruteForce.heuristics.database;

import java.util.HashMap;

/**
 * A generic neighbor table
 * 
 * @author Kristian Lundkvist
 * 
 */
public abstract class NeighborTable {

	/**
	 * The English alphabet.
	 */
	private static final char[] english = { 'a', 'b', 'c', 'd', 'e', 'f', 'g',
			'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't',
			'u', 'v', 'w', 'x', 'y', 'z' };

	/**
	 * The table holding all the items.
	 */
	private HashMap<String, TableItem> table;

	/**
	 * Default constructor.
	 */
	public NeighborTable() {
		this.table = new HashMap<String, TableItem>();
	}

	/**
	 * Constructor.
	 * 
	 * @param table
	 *            The database table holding all the relations.
	 */
	public NeighborTable(HashMap<String, TableItem> table) {
		this.table = table;
	}

	/**
	 * @return An char array with the English alphabet.
	 */
	public static char[] getEnglish() {
		return english;
	}

	/**
	 * Increases the value of nextTo for the table item.
	 * 
	 * @param reference
	 *            The reference character.
	 * @param relative
	 *            The relative character.
	 */
	public void increaseNextTo(char reference, char relative) {

		String key = reference + relative + "";

		key.trim();

		if (this.table.containsKey(key)
				|| this.table.containsKey(new StringBuilder(key).reverse()
						.toString())) {
			this.table.get(key).increaseNextTo();
		} else {
			this.table.put(key, new TableItem(reference, relative, 1, 0));
		}
	}

	/**
	 * Increases the value of apartFrom for the table item.
	 * 
	 * @param reference
	 *            The reference character.
	 * @param relative
	 *            The relative character.
	 */
	public void increaseApartFrom(char reference, char relative) {
		String key = reference + relative + "";

		key.trim();

		if (this.table.containsKey(key)
				|| this.table.containsKey(new StringBuilder(key).reverse()
						.toString())) {
			this.table.get(key).increaseApartFrom();
		} else {
			this.table.put(key, new TableItem(reference, relative, 0, 1));
		}
	}

	/**
	 * Returns the value of nextTo for the table item.
	 * 
	 * @param reference
	 *            The reference character.
	 * @param relative
	 *            The relative character.
	 * @return A long representing the amount of times the relative character
	 *         appears next to the reference character. Returns -1 if the table
	 *         item for the reference and relative character doesn't exist.
	 */
	public long getNextTo(char reference, char relative) {
		String key = reference + relative + "";

		key.trim();

		if (this.table.containsKey(key)
				|| this.table.containsKey(new StringBuilder(key).reverse()
						.toString())) {
			return this.table.get(key).getNextTo();
		} else {
			return -1;
		}
	}

	/**
	 * Returns the value of apartFrom for the table item.
	 * 
	 * @param reference
	 *            The reference character.
	 * @param relative
	 *            The relative character.
	 * @return A long representing the amount of times the relative charater
	 *         appears apart from the reference character. Returns -1 if the
	 *         table item for the reference and relative character doesn't
	 *         exist.
	 */
	public long getApartFrom(char reference, char relative) {
		String key = reference + relative + "";

		key.trim();

		if (this.table.containsKey(key)
				|| this.table.containsKey(new StringBuilder(key).reverse()
						.toString())) {
			return this.table.get(key).getApartFrom();
		} else {
			return -1;
		}
	}
}
