/**
 * 
 */
package se.althor.HeuristicBruteForce;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.HashMap;
import java.util.LinkedList;

/**
 * Generates passwords from rules.
 * 
 * @author Kristian Lundkvist
 * 
 */
public class PasswordGenerator implements Runnable {

	/**
	 * Path to the file with rules.
	 */
	private String rulesFile;

	/**
	 * The queue of generated passwords.
	 */
	private LinkedList<String> passwordQueue;

	/**
	 * True while generating passwords, false when not.
	 */
	private boolean running;

	/**
	 * The arrays holding the characters used for generating passwords.
	 * 
	 * It holds the name of the characters and the characters.
	 */
	private HashMap<String, char[]> characters;

	/**
	 * The arrays of rules.
	 * 
	 * Hold the name of the rule and the rule.
	 */
	private HashMap<String, char[]> rules;

	/**
	 * Array list with rule names.
	 */
	private LinkedList<String> ruleName;

	/**
	 * The current password generated.
	 */
	private int currentRule;

	/**
	 * Default constructor.
	 */
	public PasswordGenerator() {
		this.setRulesFile("");
		this.setPasswordQueue(new LinkedList<String>());
		this.setRunning(false);
		this.characters = new HashMap<String, char[]>();
		this.rules = new HashMap<String, char[]>();
		this.ruleName = new LinkedList<String>();
		this.setCurrentRule(0);
	}

	/**
	 * Constructor.
	 * 
	 * @param rulesFile
	 *            Path to the rules file.
	 */
	public PasswordGenerator(String rulesFile) {
		this.setRulesFile(rulesFile);
		this.setPasswordQueue(new LinkedList<String>());
		this.running = false;
		this.characters = new HashMap<String, char[]>();
		this.rules = new HashMap<String, char[]>();
		this.ruleName = new LinkedList<String>();
		this.setCurrentRule(0);
	}

	/**
	 * Initializes the password generator.
	 */
	public void init() {

		// Read the rule file.
		try {
			BufferedReader in = new BufferedReader(new FileReader(
					this.getRulesFile()));

			String line;

			while ((line = in.readLine()) != null) {
				String[] splits = line.split(" ");

				if (splits[0].equals("") || splits[0].charAt(0) == '#') {
					// Ignore, it's a comment.
				} else if (splits[0].equals("chars")) {

					// Adds a collection of characters
					this.characters.put(splits[1], splits[2].toCharArray());

				} else if (splits[0].equals("rules")) {

					// Adds a rule
					this.rules.put(splits[1], splits[2].toCharArray());

					this.ruleName.add(splits[1]);
				}

			}

			in.close();

		} catch (IOException ioe) {
			ioe.printStackTrace();
		}

	}

	@Override
	public void run() {
		while (running) {

			char[] rule = this.getRules().get(
					this.ruleName.get(this.getCurrentRule()));

			for (int i = 0; i < rule.length; i++) {
				char[] temp = new char[rule.length];
				String tempString = "" + rule[i];
				this.iterate(this.getCharacters().get(tempString), i + 1, temp, 0,
						rule);
			}
			
			this.setRunning(false);

			try {
				// Lets the thread sleep for 1/10 of a second.
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	public void startGeneration() {
		this.setRunning(true);
		this.run();
	}

	/**
	 * Iterates through the possible passwords.
	 * 
	 * @param characters
	 *            The characters to be used.
	 * @param length
	 *            The maximum length.
	 * @param temp
	 *            The array storing the password.
	 * @param position
	 *            The current position.
	 */
	private void iterate(char[] characters, int length, char[] temp,
			int position, char[] rule) {
		if (position == length) {
			String password = new String(temp);
			this.getPasswordQueue().addLast(password);
			return;
		}

		for (int i = 0; i < characters.length; i++) {
			temp[position] = characters[i];
			this.iterate(this.getCharacters().get("" + rule[position]), length,
					temp, position + 1, rule);
		}
	}

	public boolean gotPasswords() {
		return !this.getPasswordQueue().isEmpty();
	}

	/**
	 * Returns the path to the rules file.
	 * 
	 * @return Path to the rules file.
	 */
	public String getRulesFile() {
		return rulesFile;
	}

	/**
	 * Sets the path to the rule file.
	 * 
	 * @param rulesFile
	 *            The path to the new rules file.
	 */
	public void setRulesFile(String rulesFile) {
		this.rulesFile = rulesFile;
	}

	/**
	 * Returns the entire queue of passwords.
	 * 
	 * @return The queue with passwords.
	 */
	public LinkedList<String> getPasswordQueue() {
		return passwordQueue;
	}

	/**
	 * Sets the password queue.
	 * 
	 * @param passwordQueue
	 *            The new password queue.
	 */
	public void setPasswordQueue(LinkedList<String> passwordQueue) {
		this.passwordQueue = passwordQueue;
	}

	/**
	 * Returns the running state.
	 * 
	 * @return True if running, false otherwise.
	 */
	public boolean getRunning() {
		return this.running;
	}

	/**
	 * Sets running state.
	 * 
	 * @param running
	 *            True if running, false otherwise.
	 */
	public void setRunning(boolean running) {
		this.running = running;
	}

	/**
	 * Returns the hashmap of the character lists.
	 * 
	 * @return The lists with characters.
	 */
	public HashMap<String, char[]> getCharacters() {
		return this.characters;
	}

	/**
	 * Sets the new character lists.
	 * 
	 * @param characters
	 *            The new lists of characters.
	 */
	public void setCharacters(HashMap<String, char[]> characters) {
		this.characters = characters;
	}

	/**
	 * Returns the rules.
	 * 
	 * @return The rules.
	 */
	public HashMap<String, char[]> getRules() {
		return this.rules;
	}

	/**
	 * Sets the new rules.
	 * 
	 * @param The
	 *            new rules.
	 */
	public void setRules(HashMap<String, char[]> rules) {
		this.rules = rules;
	}

	/**
	 * The number of the current rule.
	 * 
	 * @return the currentPassword
	 */
	public int getCurrentRule() {
		return currentRule;
	}

	/**
	 * Sets the current rule.
	 * 
	 * @param currentPassword
	 *            The new current rule.
	 */
	public void setCurrentRule(int currentRule) {
		this.currentRule = currentRule;
	}

	/**
	 * Returns a password. Takes the next password in the queue.
	 * 
	 * @return The generated password.
	 */
	public String getPassword() {
		String temp = this.getPasswordQueue().getFirst();
		this.getPasswordQueue().removeFirst();
		return temp;
	}
}
